use std::fs::File;
use std::path::Path;

extern crate image;
use self::image::DynamicImage;
use image::{imageops, GenericImageView};

extern crate colorsys;
use colorsys::{Hsl, Rgb};

use crate::delta_utils::*;
use crate::import_types::*;

const BLENDER_TO_MILLIMETERS_SCALE_FACTOR: f32 = 100.0;
const BLENDER_Z_OFFSET_MILLIMETERS: f32 = 30.0;

// Parses the JSON spline data generated by the Blender python export script
// Finds the UV map referenced in the JSON file, scrapes image data
// Returns the spline and illumination data
pub fn load_blender_data(input_path: &Path) -> BlenderData {
    let folder_root = input_path
        .parent()
        .expect("Error getting parent path of Blender JSON file");

    let json_file = File::open(input_path).expect("Blender JSON file not found");

    let blender_data: BlenderData = serde_json::from_reader(json_file).expect("Blender JSON Parsing Failed");

    // Apply coordinate transforms like scaling/offsets
    // Grab and apply UV data as required
    match blender_data {
        BlenderData::PolySpline( bp) => {
            let mut p : BlenderPoly = bp.clone();

            p.close_loop();
            p.scale_points(BLENDER_TO_MILLIMETERS_SCALE_FACTOR);
            p.offset_points(0.0,0.0,BLENDER_Z_OFFSET_MILLIMETERS);

            let uv_full_path = folder_root.join(Path::new(&p.uv_path));
            p.color = match load_uv(uv_full_path.as_path()) {
                Ok(contents) => convert_uv(contents),
                Err(_error) => generate_placeholder_uv_data(),
            };

            return BlenderData::PolySpline(p);
        },
        BlenderData::NURBSSpline( bp) => {
            let mut p : BlenderNURBS = bp.clone();

            p.close_loop();
            p.scale_points(BLENDER_TO_MILLIMETERS_SCALE_FACTOR);
            p.offset_points(0.0,0.0,BLENDER_Z_OFFSET_MILLIMETERS);

            let uv_full_path = folder_root.join(Path::new(&p.uv_path ));
            p.color = match load_uv(uv_full_path.as_path()) {
                Ok(contents) => convert_uv(contents),
                Err(_error) => generate_placeholder_uv_data(),
            };

            return BlenderData::NURBSSpline(p);
        },
        BlenderData::Particles( bp) => {
            let mut p : BlenderParticles = bp.clone();

            p.scale_points(BLENDER_TO_MILLIMETERS_SCALE_FACTOR);
            p.offset_points(0.0,0.0,BLENDER_Z_OFFSET_MILLIMETERS);

            p.particles = sort_particles(&mut p.particles);

            let rgb = Rgb::from(&(p.color_rgba.0 as f64 * 255.0, p.color_rgba.1 as f64 * 255.0, p.color_rgba.2 as f64 * 255.0));
            let hsl = Hsl::from(&rgb);
            p.color = vec![hsl; 1];

            return BlenderData::Particles(p);
        },
        _ => println!("Unknown blender data format???"),
    };

    // TODO work out how to put close_loop(), scale_points(), and offset_points() here once, rather than requiring type-based incantation

    blender_data
}

fn load_uv(input_path: &Path) -> Result<DynamicImage, image::ImageError> {
    let img = image::open(input_path)?;
    Ok(img)
}

// The blender exported UV map is a X*Y sized RGB8 PNG file and we want a 1D set of HSL colours
fn convert_uv(image: DynamicImage) -> Vec<Hsl> {
    let width = image.dimensions().0;

    let mut next_img = image.clone();
    let first_row = imageops::crop(&mut next_img, 0, 0, width, 1);

    let hue_list: Vec<Hsl> = first_row
        .pixels()
        .into_iter()
        .map(|pixel| {
            Rgb::from((
                pixel.2[0] as f64,
                pixel.2[1] as f64,
                pixel.2[2] as f64,
                pixel.2[3] as f64,
            ))
            .as_ref()
            .into()
        })
        .collect();

    hue_list
}

// Create a fallback white fade pair to provide lighting on moves which didn't have a valid UV map provided.
fn generate_placeholder_uv_data() -> Vec<Hsl> {
    return vec![Hsl::new(0.0, 0.0, 50.0, Option::from(1.0)); 2];
}
