use std::fs::File;
use std::path::Path;

use serde::Deserialize;

extern crate image;
use image::{imageops, GenericImageView};

extern crate colorsys;
use self::image::DynamicImage;
use colorsys::{Hsl, Rgb};

#[derive(Deserialize, Debug)]
pub struct BlenderSpline {
    pub curve_length: f32,
    pub points: Vec<(f32, f32, f32, f32)>,
    #[serde(rename = "type")]
    pub spline_type: String,
    #[serde(rename = "uv")]
    pub uv_path: String,
    pub cyclic: bool,
}

pub struct IlluminatedSpline {
    pub spline: BlenderSpline,
    pub illumination: Vec<Hsl>,
}

// Parses the JSON spline data generated by the Blender python export script
// Finds the UV map referenced in the JSON file, scrapes image data
// Returns the spline and illumination data
pub fn load_blender_data(input_path: &Path) -> IlluminatedSpline {
    let folder_root = input_path
        .parent()
        .expect("Error getting parent path of JSON");

    let json_file = File::open(input_path).expect("JSON file not found");

    let bl_spline: BlenderSpline = serde_json::from_reader(json_file).expect("Error parsing json");

    let uv_relative_path = Path::new(&bl_spline.uv_path);
    let uv_full_path = folder_root.join(&uv_relative_path);

    let input_colors = match load_uv(uv_full_path.as_path()) {
        Ok(contents) => convert_uv(contents),
        Err(err) => generate_placeholder_uv_data(),
    };

    let temp: IlluminatedSpline = IlluminatedSpline {
        spline: bl_spline,
        illumination: input_colors,
    };

    return temp;
}

fn load_uv(input_path: &Path) -> Result<DynamicImage, image::ImageError> {
    let img = image::open(input_path)?;
    Ok(img)
}

// The blender exported UV map is a X*Y sized RGB8 PNG file and we want a 1D set of HSL colours
fn convert_uv(image: DynamicImage) -> Vec<Hsl> {
    let width = image.dimensions().0;
    //    println!("UV Map is {}px long, in {:?}", width, image.color());

    let mut next_img = image.clone();
    let first_row = imageops::crop(&mut next_img, 0, 0, width, 1);

    let mut hue_list: Vec<Hsl> = Vec::new();

    for pixel in first_row.pixels() {
        let rbga_tuple = (
            pixel.2[0] as f64,
            pixel.2[1] as f64,
            pixel.2[2] as f64,
            pixel.2[3] as f64,
        );
        let rgba = Rgb::from(&rbga_tuple);
        let hsla: Hsl = rgba.as_ref().into();

        hue_list.push(hsla);
    }

    return hue_list;
}

// Create a fallback white 2-point value pair to provide lighting on moves which didn't have a valid UV map provided.
fn generate_placeholder_uv_data() -> Vec<Hsl> {
    //    println!("Generating white colour as fallback for missing UV");

    let mut hue_list: Vec<Hsl> = Vec::new();
    hue_list.push(Hsl::new(0.0, 0.0, 0.5, Option::from(1.0)));
    hue_list.push(Hsl::new(0.0, 0.0, 0.5, Option::from(1.0)));

    return hue_list;
}
